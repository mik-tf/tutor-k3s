---
# Install and configure Longhorn for OpenedX - Industry-standard implementation

- name: Check if kubectl is available
  ansible.builtin.command: which kubectl
  register: kubectl_check
  ignore_errors: true
  changed_when: false

- name: Fail if kubectl is not installed
  fail:
    msg: "Error: kubectl is not installed or not in PATH"
  when: kubectl_check.rc != 0

- name: Wait for K3s API server to become responsive
  ansible.builtin.shell: |
    attempts=0
    max_attempts=30  # Increased from 12 to 30
    until kubectl get nodes --request-timeout=20s > /dev/null 2>&1 || [ $attempts -eq $max_attempts ]; do
      attempts=$((attempts+1))
      echo "Attempt $attempts/$max_attempts: Waiting for API server to respond..."
      sleep 20  # Increased from 10 to 20
    done
    if [ $attempts -eq $max_attempts ]; then
      echo "API server not responding after maximum attempts"
      exit 1
    fi
    
    # Additional check for core components
    echo "API server is responding! Now checking core components..."
    
    # Wait for core system pods
    for retry in {1..10}; do
      echo "Checking core components, attempt $retry/10"
      RUNNING_PODS=$(kubectl get pods -n kube-system --field-selector=status.phase=Running 2>/dev/null | grep -c Running || echo 0)
      if [ "$RUNNING_PODS" -ge 5 ]; then
        echo "K3s core components are ready with $RUNNING_PODS running pods."
        break
      fi
      echo "Only $RUNNING_PODS pods running in kube-system. Waiting..."
      sleep 20
    done
    
    echo "K3s API server initialization check complete!"
  environment:
    KUBECONFIG: "{{ kubeconfig }}"
  register: api_ready
  retries: 5          # Increased from 3 to 5
  delay: 15           # Increased from 5 to 15
  until: api_ready.rc == 0
  changed_when: false

- name: Clean up any failed Longhorn installation
  block:
    - name: Check if longhorn-system namespace exists
      ansible.builtin.shell: kubectl get namespace longhorn-system 2>/dev/null || echo "not found"
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      register: longhorn_ns_check
      changed_when: false
      
    - name: Check for Longhorn pods in CrashLoopBackOff state
      ansible.builtin.shell: |
        kubectl get pods -n longhorn-system -o json 2>/dev/null | 
        jq -r '.items[] | select(.status.containerStatuses[0].state.waiting.reason == "CrashLoopBackOff") | .metadata.name' || echo ""
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      register: crashed_pods
      changed_when: false
      when: "'not found' not in longhorn_ns_check.stdout"
      
    - name: Remove failed Longhorn installation if pods are crashing
      ansible.builtin.shell: |
        echo "Removing failed Longhorn installation..."
        kubectl delete namespace longhorn-system --timeout=180s
        
        # Wait for namespace deletion to complete
        echo "Waiting for namespace deletion to complete..."
        start_time=$(date +%s)
        while kubectl get namespace longhorn-system 2>/dev/null; do
          current_time=$(date +%s)
          elapsed_time=$((current_time - start_time))
          if [ $elapsed_time -gt 300 ]; then
            echo "Namespace deletion timed out after 5 minutes"
            break
          fi
          sleep 10
        done
        echo "Namespace deletion completed or timed out"
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      register: cleanup_result
      when: crashed_pods.stdout | default('') != '' and crashed_pods.stdout | length > 0
      changed_when: cleanup_result.rc == 0
  when: "'not found' not in longhorn_ns_check.stdout | default('')"

- name: Install open-iscsi on all nodes
  block:
    - name: Get list of nodes
      ansible.builtin.shell: kubectl get nodes -o jsonpath='{.items[*].metadata.name}'
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      register: nodes_list
      changed_when: false
      
    - name: Create open-iscsi installation script
      ansible.builtin.copy:
        dest: /tmp/install-iscsi.sh
        mode: 0755
        content: |
          #!/bin/bash
          set -e
          
          NODE=$1
          echo "Installing open-iscsi on $NODE..."
          
          # Create debug pod to install open-iscsi
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: Pod
          metadata:
            name: install-iscsi-$NODE
            namespace: kube-system
          spec:
            nodeName: $NODE
            hostNetwork: true
            hostPID: true
            hostIPC: true
            restartPolicy: Never
            containers:
            - name: installer
              image: ubuntu:20.04
              command:
              - /bin/bash
              - -c
              - |
                apt-get update
                apt-get install -y open-iscsi
                systemctl enable iscsid
                systemctl start iscsid
                echo "Installation completed"
                sleep 10
              securityContext:
                privileged: true
                procMount: Default
              volumeMounts:
              - name: host
                mountPath: /host
            volumes:
            - name: host
              hostPath:
                path: /
          EOF
          
          # Wait for pod to complete
          echo "Waiting for installer pod to complete..."
          kubectl wait --for=condition=Ready pod/install-iscsi-$NODE -n kube-system --timeout=120s
          
          # Check pod logs
          kubectl logs install-iscsi-$NODE -n kube-system
          
          # Clean up pod
          kubectl delete pod install-iscsi-$NODE -n kube-system
      
    - name: Install open-iscsi on each node
      ansible.builtin.shell: |
        /tmp/install-iscsi.sh {{ item }}
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      with_items: "{{ nodes_list.stdout.split() }}"
      register: iscsi_install
      changed_when: "'Installation completed' in iscsi_install.stdout"
      failed_when: false  # Continue even if some nodes fail
      
    - name: Display open-iscsi installation results
      debug:
        msg: "{{ iscsi_install.results | map(attribute='stdout_lines') | list }}"

- name: Create longhorn-system namespace
  ansible.builtin.shell: |
    kubectl create namespace longhorn-system --dry-run=client -o yaml | kubectl apply -f - --validate=false
  environment:
    KUBECONFIG: "{{ kubeconfig }}"
  register: longhorn_ns
  retries: 5
  delay: 10
  until: longhorn_ns.rc == 0
  changed_when: "'created' in longhorn_ns.stdout"

- name: Download Longhorn manifest to local file
  ansible.builtin.get_url:
    url: https://raw.githubusercontent.com/longhorn/longhorn/v1.5.1/deploy/longhorn.yaml
    dest: /tmp/longhorn.yaml
    mode: '0644'
  register: download_result

- name: Apply Longhorn manifest with validation disabled and timeout
  ansible.builtin.shell: |
    # Apply with increased timeout and validation disabled
    kubectl apply -f /tmp/longhorn.yaml --validate=false --timeout=300s
  environment:
    KUBECONFIG: "{{ kubeconfig }}"
  register: longhorn_install
  retries: 3
  delay: 30
  until: longhorn_install.rc == 0
  changed_when: longhorn_install.rc == 0

- name: Wait for core Longhorn CRDs to be established
  ansible.builtin.shell: |
    echo "Waiting for Longhorn CRDs to be established..."
    kubectl wait --for=condition=established --timeout=300s crd/volumes.longhorn.io crd/engines.longhorn.io crd/replicas.longhorn.io crd/settings.longhorn.io || echo "Waiting for CRDs timed out, continuing anyway"
  environment:
    KUBECONFIG: "{{ kubeconfig }}"
  register: crds_ready
  retries: 3
  delay: 30
  until: crds_ready.rc == 0
  changed_when: false
  failed_when: false  # Continue even if timeout

- name: Wait for deployments to be created
  ansible.builtin.pause:
    seconds: 60
    prompt: "Waiting for Longhorn to create initial resources..."

- name: Wait for Longhorn components to be available with improved retry logic
  block:
    - name: Wait for Longhorn components to be available
      ansible.builtin.shell: |
        # Define components to wait for
        COMPONENTS=("longhorn-ui" "longhorn-driver-deployer")
        
        # Check if deployments exist yet
        for component in "${COMPONENTS[@]}"; do
          echo "Checking if $component deployment exists..."
          attempts=0
          max_attempts=10
          until kubectl -n longhorn-system get deployment $component 2>/dev/null || [ $attempts -eq $max_attempts ]; do
            attempts=$((attempts+1))
            echo "Attempt $attempts/$max_attempts: Waiting for $component deployment to be created..."
            sleep 15
          done
          
          if [ $attempts -eq $max_attempts ]; then
            echo "Warning: Timed out waiting for $component deployment"
            continue
          fi
          
          echo "Waiting for $component rollout..."
          kubectl -n longhorn-system rollout status deployment/$component --timeout=300s || echo "Rollout timed out for $component"
        done
        
        echo "Checking Longhorn manager daemonset..."
        kubectl -n longhorn-system rollout status daemonset/longhorn-manager --timeout=300s || echo "Rollout timed out for longhorn-manager"
        
        # Check overall pod status
        RUNNING_PODS=$(kubectl get pods -n longhorn-system -o json | jq -r '.items[] | select(.status.phase == "Running") | .metadata.name' | wc -l)
        TOTAL_PODS=$(kubectl get pods -n longhorn-system -o json | jq -r '.items[] | .metadata.name' | wc -l)
        
        echo "Longhorn status: $RUNNING_PODS/$TOTAL_PODS pods running"
        if [ $RUNNING_PODS -lt 1 ]; then
          echo "Warning: No Longhorn pods are running"
          exit 1
        fi
        
        echo "Longhorn components check completed"
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      register: longhorn_status
      retries: 2
      delay: 60
      until: longhorn_status.rc == 0
      changed_when: false
      failed_when: false  # Continue even if some components aren't ready
  rescue:
    - name: Display Longhorn pod status
      ansible.builtin.shell: |
        echo "==== Longhorn Pod Status ===="
        kubectl get pods -n longhorn-system
        
        echo -e "\n==== Detailed Pod Description ===="
        CRASHED_PODS=$(kubectl get pods -n longhorn-system | grep -v Running | grep -v Completed | awk '{print $1}')
        if [ ! -z "$CRASHED_PODS" ]; then
          for pod in $CRASHED_PODS; do
            echo -e "\n--- Details for pod $pod ---"
            kubectl describe pod -n longhorn-system $pod
            echo -e "\n--- Logs for pod $pod ---"
            kubectl logs -n longhorn-system $pod --tail=50 || echo "Could not get logs"
          done
        fi
        
        echo -e "\n==== Longhorn Events ===="
        kubectl get events -n longhorn-system --sort-by='.lastTimestamp' | tail -10
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      changed_when: false

- name: Create optimized StorageClass for databases
  ansible.builtin.shell: |
    cat <<EOF | kubectl apply -f - --validate=false
    apiVersion: storage.k8s.io/v1
    kind: StorageClass
    metadata:
      name: longhorn-db-optimized
    provisioner: driver.longhorn.io
    allowVolumeExpansion: true
    parameters:
      numberOfReplicas: "{{ longhorn_replica_count | default('2') }}"
      staleReplicaTimeout: "30"
      fsType: "ext4"
    EOF
  environment:
    KUBECONFIG: "{{ kubeconfig }}"
  register: db_sc_created
  retries: 5
  delay: 10
  until: db_sc_created.rc == 0
  changed_when: db_sc_created.rc == 0
  failed_when: false

- name: Set Longhorn as default StorageClass with improved error handling
  ansible.builtin.shell: |
    # First verify that Longhorn StorageClass exists
    if ! kubectl get storageclass longhorn &>/dev/null; then
      echo "Longhorn StorageClass not found, waiting..."
      # Try a few more times
      for i in {1..5}; do
        sleep 10
        if kubectl get storageclass longhorn &>/dev/null; then
          echo "Longhorn StorageClass found on retry $i"
          break
        fi
        echo "Retry $i: Longhorn StorageClass still not found"
      done
    fi
    
    # Check again and proceed only if found
    if kubectl get storageclass longhorn &>/dev/null; then
      # Unset any existing default
      kubectl get storageclass -o json | jq -r '.items[] | select(.metadata.annotations["storageclass.kubernetes.io/is-default-class"] == "true") | .metadata.name' | while read sc; do
        kubectl patch storageclass $sc -p '{"metadata": {"annotations":{"storageclass.kubernetes.io/is-default-class":"false"}}}'
      done
      
      # Set Longhorn as default
      kubectl patch storageclass longhorn -p '{"metadata": {"annotations":{"storageclass.kubernetes.io/is-default-class":"true"}}}'
      echo "Longhorn set as default StorageClass"
    else
      echo "Warning: Could not find Longhorn StorageClass, not setting as default"
      exit 1
    fi
  environment:
    KUBECONFIG: "{{ kubeconfig }}"
  register: set_default_sc
  retries: 3
  delay: 15
  until: set_default_sc.rc == 0
  changed_when: set_default_sc.rc == 0
  failed_when: false  # Continue even if failed

- name: Configure Longhorn settings with retry
  ansible.builtin.shell: |
    # Check if Longhorn settings CRD exists
    if ! kubectl get crd settings.longhorn.io &>/dev/null; then
      echo "Settings CRD not found, waiting..."
      exit 1
    fi
    
    kubectl apply -f - --validate=false <<EOF
    apiVersion: longhorn.io/v1beta1
    kind: Setting
    metadata:
      name: {{ item.name }}
      namespace: longhorn-system
    value: "{{ item.value }}"
    EOF
  environment:
    KUBECONFIG: "{{ kubeconfig }}"
  with_items:
    - { name: "default-replica-count", value: "{{ longhorn_replica_count | default('2') }}" }
    - { name: "guaranteed-engine-cpu", value: "0.2" }
    - { name: "guaranteed-replica-cpu", value: "0.15" }
    - { name: "replica-soft-anti-affinity", value: "true" }
    - { name: "storage-over-provisioning-percentage", value: "200" }
    - { name: "auto-salvage", value: "true" }
  register: longhorn_settings
  retries: 6
  delay: 15
  until: longhorn_settings.rc == 0
  changed_when: longhorn_settings.rc == 0
  failed_when: false

- name: Configure recurring snapshots with retry
  ansible.builtin.shell: |
    # Check if we can create snapshot jobs
    if ! kubectl get crd recurringjobs.longhorn.io &>/dev/null; then
      echo "RecurringJobs CRD not found, waiting..."
      exit 1
    fi
    
    kubectl apply -f - --validate=false <<EOF
    apiVersion: longhorn.io/v1beta1
    kind: RecurringJob
    metadata:
      name: daily-snapshot
      namespace: longhorn-system
    spec:
      cron: "0 0 * * *"
      task: snapshot
      groups:
      - default
      retain: 7
      concurrency: 2
    EOF
  environment:
    KUBECONFIG: "{{ kubeconfig }}"
  register: snapshot_job
  retries: 6
  delay: 15
  until: snapshot_job.rc == 0
  changed_when: snapshot_job.rc == 0
  when: longhorn_enable_snapshots | default(true) | bool
  failed_when: false

- name: Verify Longhorn status
  ansible.builtin.shell: |
    echo "=== Longhorn Components Status ==="
    kubectl -n longhorn-system get pods

    echo -e "\n=== Longhorn StorageClasses ==="
    kubectl get storageclass

    echo -e "\n=== Longhorn Volume Status ==="
    kubectl -n longhorn-system get volumes.longhorn.io || echo "Volumes not available yet"

    # Get actual replica count
    REPLICA_COUNT="{{ '{{' }} longhorn_replica_count | default('2') {{ '}}' }}"
    ACTUAL_COUNT=$(kubectl -n longhorn-system get settings default-replica-count -o jsonpath='{.value}' 2>/dev/null || echo "unknown")
    echo -e "\nReplica count configured: $REPLICA_COUNT, Actual: $ACTUAL_COUNT"

    # Final verdict on Longhorn readiness
    READY_PODS=$(kubectl get pods -n longhorn-system --field-selector=status.phase=Running | grep -c Running || echo 0)
    TOTAL_PODS=$(kubectl get pods -n longhorn-system | grep -c -v "NAME" || echo 0)

    echo -e "\nLonghorn readiness: $READY_PODS/$TOTAL_PODS pods running"

    if [ $READY_PODS -lt 3 ]; then
      echo "WARNING: Not all Longhorn pods are running. Check the logs for errors."
    else
      echo "SUCCESS: Longhorn appears to be running properly!"
    fi
  environment:
    KUBECONFIG: "{{ kubeconfig }}"
  register: longhorn_verification
  changed_when: false
  failed_when: false

- name: Display Longhorn status
  debug:
    msg: "{{ longhorn_verification.stdout_lines }}"

- name: Final Longhorn readiness check
  debug:
    msg: |
      {% if 'SUCCESS: Longhorn appears to be running properly!' in longhorn_verification.stdout %}
      Longhorn storage has been successfully deployed and is ready to use.
      
      Now you can deploy OpenedX with reliable storage by running:
      make deploy
      
      Any PVCs created will automatically use Longhorn storage.
      {% else %}
      Longhorn installation completed but some components may not be fully ready.
      This is sometimes normal during initial startup.
      
      You can check status with:
      kubectl get pods -n longhorn-system
      
      You can still proceed with OpenedX deployment, which may succeed if core
      components are working, or retry the storage setup:
      make setup-storage
      {% endif %}